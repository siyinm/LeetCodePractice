Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

```
Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```




### Solution

1. 重复子列出现在哪些部分？ 假设元素列(nums)为：[1, 2, 2]，下面进行模拟

   - 遍历完第一个元素--->[[], [1]]
   - 遍历完第二个元素--->[[], [1], [2], [1, 2]]
   - 遍历完第三个元素--->[[], [1], [2], [1, 2], **[2]**, **[1, 2]**, [2, 2], [1, 2, 2]]。

   加粗部分就是第三个元素遍历以后，产生的重复部分。[ **[2]**, **[1, 2]**]是因为第三个元素`2`，在与[[], [1]]生成新序列时生成的，可以看到这个过程与第二个元素`2`生成新序列的过程时一样的。即重复序列就是第三个元素在与[[], [1]]生成新序列时生成的，同时注意到[[], [1]]之后的序列就是第二元素遍历时生成的新序列，而第三个序列与这些新序列不会生成重复序列，同时注意每次生成的新序列的长度是可以被记录的。

2. 如何避免生成重复序列 在了解重复序列出现的原因和位置以后，就可以去重操作了。

   - 先进行排序，保证重复元素挨在一起
   - 记录每次遍历生成的新序列的长度，这里用`left`表示每次遍历的开始位置，`right`结束位置，`len`表示长度
   - 根据与前面元素是否重复，来决定`left`的取值，也就是开始遍历的位置

   上述三个步骤就能有效避免当前元素与之前相同元素遍历过程发生重叠。

